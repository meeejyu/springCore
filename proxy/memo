프록시, 프록시 패턴, 데코레이터 패턴

프록시는?
    객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야한다.
    쉽게 말해서 서버와 프록시는 같은 인터페이스를 사용해야 한다.
    그리고 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.

프록시의 주요 기능 2가지
1. 접근제어
    권한에 따른 접근 차단
    캐싱
    지연로딩
2. 부가 기능 추가
    원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다

GOF 디자인 패턴
둘다 프록시를 사용하는 방법이지만 의도에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다
    프록시 패턴 : 접근 제어가 목적
    데코레이터 패턴 : 새로운 기능 추가가 목적

인터페이스 기반 프록시 적용
프록시 의존 관계 추가
    client -> orderControllerProxy(프록시) -> orderControllerImpl -> orderServiceProxy(프록시) -> orderServiceImpl

클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다
    부모 클래스의 생성자를 호출해야 한다
    클래스에 final 키워드가 붙으면 상속이 불가능하다
    메소드 final 키워드를 붙으면 해당 메소드를 오버라이딩 할 수 없다.

JDK 동적 프록시가 제공하는 InvocationHandler

public interface InvocationHandler {

    public Object invoke(Object proxy, Meshto method, Object[] args) 
        throws Throwable;
}

제공하는 파라미터 
    Object Proxy : 프록시 자신
    Method method : 호출한 메서드
    Object[] args : 메서드를 호출할 때 전달한 인수

CGLIB 코드

    public interface MethodInterceptor extends Callback {
        Object intercept(Object obj, Method method, Object[] args, MethodProxy
    proxy) throws Throwable;
    }
제공하는 파라미터
obj : CGLIB가 적용된 객체
method : 호출된 메서드
args : 메서드를 호출하면서 전달된 인수 
proxy : 메서드 호출에 사용

CGLIB 제약
    클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
    부모 클래스의 생성자를 체크해야 한다. CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
    클래스에 final 키워드가 붙으면 상속이 불가능하다. CGLIB에서는 예외가 발생한다. 
    메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. CGLIB에서는 프록시 로직이 동작하지 않는다.


ProxyFactory

Advice 만들기
Advice 는 프록시에 적용하는 부가 기능 로직이다. 
이것은 JDK 동적 프록시가 제공하는 InvocationHandler 와 CGLIB가 제공하는 MethodInterceptor 의 개념과 유사한다. 
둘을 개념적으로 추상화 한 것이다. 프록시 팩토리를 사용하면 둘 대신에 Advice 를 사용하면 된다.
Advice 를 만드는 방법은 여러가지가 있지만, 기본적인 방법은 다음 인터페이스를 구현하면 된다.

MethodInterceptor - 스프링이 제공하는 코드
  package org.aopalliance.intercept;
  public interface MethodInterceptor extends Interceptor {
      Object invoke(MethodInvocation invocation) throws Throwable;
}
MethodInvocation invocation
내부에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, args , 메서드 정보 등이 포함되어 있다. 
기존에 파라미터로 제공되는 부분들이 이 안으로 모두 들어갔다고 생각하면 된다.
CGLIB의 MethodInterceptor 와 이름이 같으므로 패키지 이름에 주의하자
참고로 여기서 사용하는 org.aopalliance.intercept 패키지는 스프링 AOP 모듈( spring-top ) 안에 들어있다.
MethodInterceptor 는 Interceptor 를 상속하고 Interceptor 는 Advice 인터페이스를 상속한다.

프록시 팩토리의 기술 선택 방법
대상에 인터페이스가 있으면: JDK 동적 프록시, 인터페이스 기반 프록시 
대상에 인터페이스가 없으면: CGLIB, 구체 클래스 기반 프록시
proxyTargetClass=true : CGLIB, 구체 클래스 기반 프록시, 인터페이스 여부와 상관없음

정리
프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우 편리하게 동적 프록시를 생성할 수 있다.
프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 Advice 하나로 편리하게 사용할 수 있었다. 
이것은 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 InvocationHandler 가 Advice 를 호출하도록 개발해두고, 
CGLIB인 경우 MethodInterceptor 가 Advice 를 호출하도록 기능을 개발해두었기 때문이다.

참고
스프링 부트는 AOP를 적용할 때 기본적으로 proxyTargetClass=true 로 설정해서 사용한다. > 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다.
