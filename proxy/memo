프록시, 프록시 패턴, 데코레이터 패턴

프록시는?
    객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야한다.
    쉽게 말해서 서버와 프록시는 같은 인터페이스를 사용해야 한다.
    그리고 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.

프록시의 주요 기능 2가지
1. 접근제어
    권한에 따른 접근 차단
    캐싱
    지연로딩
2. 부가 기능 추가
    원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다

GOF 디자인 패턴
둘다 프록시를 사용하는 방법이지만 의도에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다
    프록시 패턴 : 접근 제어가 목적
    데코레이터 패턴 : 새로운 기능 추가가 목적

인터페이스 기반 프록시 적용
프록시 의존 관계 추가
    client -> orderControllerProxy(프록시) -> orderControllerImpl -> orderServiceProxy(프록시) -> orderServiceImpl

클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다
    부모 클래스의 생성자를 호출해야 한다
    클래스에 final 키워드가 붙으면 상속이 불가능하다
    메소드 final 키워드를 붙으면 해당 메소드를 오버라이딩 할 수 없다.

JDK 동적 프록시가 제공하는 InvocationHandler

public interface InvocationHandler {

    public Object invoke(Object proxy, Meshto method, Object[] args) 
        throws Throwable;
}

제공하는 파라미터 
    Object Proxy : 프록시 자신
    Method method : 호출한 메서드
    Object[] args : 메서드를 호출할 때 전달한 인수

CGLIB 코드

    public interface MethodInterceptor extends Callback {
        Object intercept(Object obj, Method method, Object[] args, MethodProxy
    proxy) throws Throwable;
    }
제공하는 파라미터
obj : CGLIB가 적용된 객체
method : 호출된 메서드
args : 메서드를 호출하면서 전달된 인수 
proxy : 메서드 호출에 사용

CGLIB 제약
    클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
    부모 클래스의 생성자를 체크해야 한다. CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
    클래스에 final 키워드가 붙으면 상속이 불가능하다. CGLIB에서는 예외가 발생한다. 
    메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. CGLIB에서는 프록시 로직이 동작하지 않는다.

